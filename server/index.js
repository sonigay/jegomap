require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { google } = require('googleapis');
const NodeGeocoder = require('node-geocoder');

// Í∏∞Î≥∏ ÏÑ§Ï†ï
const app = express();
const port = process.env.PORT || 4000;

// Ï∫êÏã± ÏãúÏä§ÌÖú ÏÑ§Ï†ï
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5Î∂Ñ (5 * 60 * 1000ms)
const MAX_CACHE_SIZE = 100; // ÏµúÎåÄ Ï∫êÏãú Ìï≠Î™© Ïàò

// Ï∫êÏãú Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
const cacheUtils = {
  // Ï∫êÏãúÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
  set: (key, data, ttl = CACHE_TTL) => {
    const now = Date.now();
    cache.set(key, {
      data,
      timestamp: now,
      ttl: now + ttl
    });
    
    // Ï∫êÏãú ÌÅ¨Í∏∞ Ï†úÌïú ÌôïÏù∏
    if (cache.size > MAX_CACHE_SIZE) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    console.log(`Ï∫êÏãú Ï†ÄÏû•: ${key} (TTL: ${new Date(now + ttl).toLocaleTimeString()})`);
  },
  
  // Ï∫êÏãúÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
  get: (key) => {
    const item = cache.get(key);
    if (!item) {
      console.log(`Ï∫êÏãú ÎØ∏Ïä§: ${key}`);
      return null;
    }
    
    const now = Date.now();
    if (now > item.ttl) {
      cache.delete(key);
      console.log(`Ï∫êÏãú ÎßåÎ£å: ${key}`);
      return null;
    }
    
    console.log(`Ï∫êÏãú ÌûàÌä∏: ${key}`);
    return item.data;
  },
  
  // Ï∫êÏãú ÏÇ≠Ï†ú
  delete: (key) => {
    cache.delete(key);
    console.log(`Ï∫êÏãú ÏÇ≠Ï†ú: ${key}`);
  },
  
  // Ï∫êÏãú Ï†ÑÏ≤¥ Ï†ïÎ¶¨ (ÎßåÎ£åÎêú Ìï≠Î™©Îì§)
  cleanup: () => {
    const now = Date.now();
    let deletedCount = 0;
    
    for (const [key, item] of cache.entries()) {
      if (now > item.ttl) {
        cache.delete(key);
        deletedCount++;
      }
    }
    
    if (deletedCount > 0) {
      console.log(`Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å: ${deletedCount}Í∞ú Ìï≠Î™© ÏÇ≠Ï†ú`);
    }
  },
  
  // Ï∫êÏãú ÏÉÅÌÉú ÌôïÏù∏
  status: () => {
    const now = Date.now();
    const validItems = Array.from(cache.entries()).filter(([key, item]) => now <= item.ttl);
    return {
      total: cache.size,
      valid: validItems.length,
      expired: cache.size - validItems.length
    };
  }
};

// Ï£ºÍ∏∞Ï†Å Ï∫êÏãú Ï†ïÎ¶¨ (5Î∂ÑÎßàÎã§)
setInterval(() => {
  cacheUtils.cleanup();
}, 5 * 60 * 1000);

// Discord Î¥á ÏÑ§Ï†ï
const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
const DISCORD_CHANNEL_ID = process.env.DISCORD_CHANNEL_ID;
const DISCORD_AGENT_CHANNEL_ID = process.env.DISCORD_AGENT_CHANNEL_ID || DISCORD_CHANNEL_ID; // Í¥ÄÎ¶¨Ïûê Ï±ÑÎÑê (ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Ï±ÑÎÑê ÏÇ¨Ïö©)
const DISCORD_STORE_CHANNEL_ID = process.env.DISCORD_STORE_CHANNEL_ID || DISCORD_CHANNEL_ID; // ÏùºÎ∞ò Îß§Ïû• Ï±ÑÎÑê (ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Ï±ÑÎÑê ÏÇ¨Ïö©)
const DISCORD_LOGGING_ENABLED = process.env.DISCORD_LOGGING_ENABLED === 'true';

// ÎîîÏä§ÏΩîÎìú Î¥á Î∞è Í¥ÄÎ†® ÎùºÏù¥Î∏åÎü¨Î¶¨Îäî ÌïÑÏöîÌïú Í≤ΩÏö∞ÏóêÎßå Ï¥àÍ∏∞Ìôî
let discordBot = null;
let EmbedBuilder = null;

if (DISCORD_LOGGING_ENABLED && DISCORD_BOT_TOKEN) {
  try {
    const { Client, GatewayIntentBits } = require('discord.js');
    ({ EmbedBuilder } = require('discord.js'));
    
    // ÎîîÏä§ÏΩîÎìú Î¥á Ï¥àÍ∏∞Ìôî
    discordBot = new Client({ 
      intents: [
        GatewayIntentBits.Guilds, 
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
      ]
    });
    
    // Î¥á Ï§ÄÎπÑ Ïù¥Î≤§Ìä∏
    discordBot.once('ready', () => {
      console.log(`Î¥áÏù¥ Ï§ÄÎπÑÎêòÏóàÏäµÎãàÎã§: ${discordBot.user.tag}`);
    });
    
    console.log('ÎîîÏä§ÏΩîÎìú Î¥á Î™®Îìà Î°úÎî© ÏÑ±Í≥µ');
  } catch (error) {
    console.error('ÎîîÏä§ÏΩîÎìú Î¥á Î™®Îìà Î°úÎî© Ïã§Ìå®:', error.message);
  }
}

// Ï†ÑÏó≠ Ïò§Î•ò Ï≤òÎ¶¨
process.on('uncaughtException', async (error) => {
  console.error('Uncaught Exception:', error);
  
  // DiscordÏóê Ïò§Î•ò ÏïåÎ¶º Ï†ÑÏÜ°
  if (DISCORD_LOGGING_ENABLED && discordBot) {
    try {
      // Î¥áÏù¥ Ï§ÄÎπÑÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      if (discordBot.isReady()) {
        if (DISCORD_CHANNEL_ID) {
          try {
            const channel = await discordBot.channels.fetch(DISCORD_CHANNEL_ID);
            if (channel) {
              // ÏóêÎü¨ Ï†ïÎ≥¥Î•º Í∞ÑÍ≤∞ÌïòÍ≤å Ï†ïÎ¶¨
              const errorInfo = {
                message: error.message,
                stack: error.stack?.split('\n').slice(0, 5).join('\n') || 'Ïä§ÌÉù Ï†ïÎ≥¥ ÏóÜÏùå',
                time: new Date().toISOString()
              };
              
              const crashEmbed = new EmbedBuilder()
                .setTitle('üö® ÏÑúÎ≤Ñ Ï∂©Îèå ÏïåÎ¶º')
                .setColor(15548997) // Îπ®Í∞ÑÏÉâ
                .setDescription('@everyone\nÏÑúÎ≤ÑÏóê ÏπòÎ™ÖÏ†ÅÏù∏ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÏÑúÎπÑÏä§Í∞Ä Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§.')
                .addFields({
                  name: 'Ïò§Î•ò Ï†ïÎ≥¥',
                  value: `\`\`\`\n${errorInfo.message}\n${errorInfo.stack}\n\`\`\``
                })
                .setTimestamp()
                .setFooter({ text: 'VIP+ ÏÑúÎ≤Ñ Ïò§Î•ò ÏïåÎ¶º' });
                
              console.log('Ï∂©Îèå ÏïåÎ¶º Ï†ÑÏÜ° ÏãúÎèÑ Ï§ë...');
              await channel.send({ content: '@everyone', embeds: [crashEmbed] });
              console.log('ÏÑúÎ≤Ñ Ï∂©Îèå ÏïåÎ¶º Î©îÏãúÏßÄÍ∞Ä DiscordÎ°ú Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§.');
            }
          } catch (discordError) {
            console.error('Discord Ï∂©Îèå ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', discordError);
          }
        }
      }
      
      // Discord Î©îÏãúÏßÄ Ï†ÑÏÜ°ÏùÑ ÏúÑÌïú ÎåÄÍ∏∞
      await new Promise(resolve => setTimeout(resolve, 3000));
    } catch (discordError) {
      console.error('Discord Ïò§Î•ò ÏïåÎ¶º Ï≤òÎ¶¨ Ï§ë Ï∂îÍ∞Ä Ïò§Î•ò:', discordError);
    }
  }
  
  // 3Ï¥à ÌõÑ ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å (Discord Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÍ∞Ñ ÌôïÎ≥¥)
  setTimeout(() => {
    console.error('ÏπòÎ™ÖÏ†ÅÏù∏ Ïò§Î•òÎ°ú Ïù∏Ìïú ÏÑúÎ≤Ñ Ï¢ÖÎ£å');
    process.exit(1);
  }, 3000);
});

process.on('unhandledRejection', async (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  
  // ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ DiscordÏóê Í≤ΩÍ≥† ÏïåÎ¶ºÎßå Ï†ÑÏÜ°
  if (DISCORD_LOGGING_ENABLED && discordBot && discordBot.isReady()) {
    try {
      if (DISCORD_CHANNEL_ID) {
        const channel = await discordBot.channels.fetch(DISCORD_CHANNEL_ID);
        if (channel) {
          // Ïò§Î•ò Ï†ïÎ≥¥ Ï†ïÎ¶¨
          const errorInfo = {
            message: reason instanceof Error ? reason.message : String(reason),
            stack: reason instanceof Error && reason.stack 
              ? reason.stack.split('\n').slice(0, 5).join('\n') 
              : 'Ïä§ÌÉù Ï†ïÎ≥¥ ÏóÜÏùå',
            time: new Date().toISOString()
          };
          
          const warningEmbed = new EmbedBuilder()
            .setTitle('‚ö†Ô∏è ÏÑúÎ≤Ñ Í≤ΩÍ≥† ÏïåÎ¶º')
            .setColor(16776960) // ÎÖ∏ÎûÄÏÉâ
            .setDescription('ÏÑúÎ≤ÑÏóêÏÑú Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Promise Í±∞Î∂ÄÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
            .addFields({
              name: 'Ïò§Î•ò Ï†ïÎ≥¥',
              value: `\`\`\`\n${errorInfo.message}\n${errorInfo.stack}\n\`\`\``
            })
            .setTimestamp()
            .setFooter({ text: 'VIP+ ÏÑúÎ≤Ñ Í≤ΩÍ≥† ÏïåÎ¶º' });
            
          await channel.send({ embeds: [warningEmbed] });
          console.log('ÏÑúÎ≤Ñ Í≤ΩÍ≥† ÏïåÎ¶º Î©îÏãúÏßÄÍ∞Ä DiscordÎ°ú Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§.');
        }
      }
    } catch (discordError) {
      console.error('Discord Í≤ΩÍ≥† ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', discordError);
    }
  }
  
  // Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Promise Í±∞Î∂ÄÎ•º Í∏∞Î°ùÌïòÏßÄÎßå ÌîÑÎ°úÏÑ∏Ïä§Îäî Í≥ÑÏÜç Ïã§Ìñâ
});

// Î™®Îì† ÏöîÏ≤≠Ïóê ÎåÄÌïú Î°úÍπÖ ÎØ∏Îì§Ïõ®Ïñ¥
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  next();
});

// CORS ÏÑ§Ï†ï
app.use(cors());
app.use(express.json());

// Google Sheets API configuration
const SPREADSHEET_ID = process.env.SHEET_ID;
const GOOGLE_PRIVATE_KEY = process.env.GOOGLE_PRIVATE_KEY;
const GOOGLE_SERVICE_ACCOUNT_EMAIL = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL;

// ÌïÑÏàò ÌôòÍ≤Ω Î≥ÄÏàò Í≤ÄÏ¶ù
if (!SPREADSHEET_ID) {
  console.error('SHEET_ID is not defined in environment variables');
  process.exit(1);
}

if (!GOOGLE_SERVICE_ACCOUNT_EMAIL) {
  console.error('GOOGLE_SERVICE_ACCOUNT_EMAIL is not defined in environment variables');
  process.exit(1);
}

if (!GOOGLE_PRIVATE_KEY) {
  console.error('GOOGLE_PRIVATE_KEY is not defined in environment variables');
  process.exit(1);
}

// ÏãúÌä∏ Ïù¥Î¶Ñ ÏÑ§Ï†ï
const INVENTORY_SHEET_NAME = 'Ìè∞ÌÅ¥Ïû¨Í≥†Îç∞Ïù¥ÌÑ∞';
const STORE_SHEET_NAME = 'Ìè∞ÌÅ¥Ï∂úÍ≥†Ï≤òÎç∞Ïù¥ÌÑ∞';
const AGENT_SHEET_NAME = 'ÎåÄÎ¶¨Ï†êÏïÑÏù¥ÎîîÍ¥ÄÎ¶¨';  // ÎåÄÎ¶¨Ï†ê ÏïÑÏù¥Îîî Í¥ÄÎ¶¨ ÏãúÌä∏ Ï∂îÍ∞Ä

// Kakao geocoding Ìï®Ïàò
async function geocodeAddressWithKakao(address) {
  const apiKey = process.env.KAKAO_API_KEY;
  if (!apiKey) {
    throw new Error('KAKAO_API_KEY ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
  }
  const encodedAddress = encodeURIComponent(address);
  const url = `https://dapi.kakao.com/v2/local/search/address.json?query=${encodedAddress}`;
  const response = await fetch(url, {
    headers: {
      'Authorization': `KakaoAK ${apiKey}`
    }
  });
  if (!response.ok) {
    throw new Error(`Kakao geocoding API Ïò§Î•ò: ${response.status}`);
  }
  const data = await response.json();
  if (data.documents && data.documents.length > 0) {
    const doc = data.documents[0];
    return {
      latitude: parseFloat(doc.y),
      longitude: parseFloat(doc.x)
    };
  }
  return null;
}

// Î©îÏù∏ geocoding Ìï®Ïàò (KakaoÎßå ÏÇ¨Ïö©)
async function geocodeAddress(address) {
  return await geocodeAddressWithKakao(address);
}

// Geocoder ÏÑ§Ï†ï (Í∏∞Ï°¥ ÏΩîÎìúÏôÄ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ïú†ÏßÄ)
const geocoder = {
  geocode: async (address) => {
    const result = await geocodeAddress(address);
    return result ? [result] : [];
  }
};

// Google API Ïù∏Ï¶ù ÏÑ§Ï†ï
const auth = new google.auth.JWT({
  email: GOOGLE_SERVICE_ACCOUNT_EMAIL,
  key: GOOGLE_PRIVATE_KEY.includes('\\n') ? GOOGLE_PRIVATE_KEY.replace(/\\n/g, '\n') : GOOGLE_PRIVATE_KEY,
  scopes: ['https://www.googleapis.com/auth/spreadsheets']
});

// Google Sheets API Ï¥àÍ∏∞Ìôî
const sheets = google.sheets({ version: 'v4', auth });

// Îç∞Ïù¥ÌÑ∞ ÏãúÌä∏ÏóêÏÑú Í∞í Í∞ÄÏ†∏Ïò§Í∏∞ (Ï∫êÏã± Ï†ÅÏö©)
async function getSheetValues(sheetName) {
  const cacheKey = `sheet_${sheetName}`;
  
  // Ï∫êÏãúÏóêÏÑú Î®ºÏ†Ä ÌôïÏù∏
  const cachedData = cacheUtils.get(cacheKey);
  if (cachedData) {
    return cachedData;
  }
  
  try {
    console.log(`Google Sheets API Ìò∏Ï∂ú: ${sheetName}`);
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: sheetName
    });
    
    const data = response.data.values || [];
    
    // Ï∫êÏãúÏóê Ï†ÄÏû• (5Î∂Ñ TTL)
    cacheUtils.set(cacheKey, data);
    
    return data;
  } catch (error) {
    console.error(`Error fetching sheet ${sheetName}:`, error);
    throw error;
  }
}

// DiscordÎ°ú Î°úÍ∑∏ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ìï®Ïàò
async function sendLogToDiscord(embedData) {
  // ÌïÑÏöîÌïú ÏÑ§Ï†ïÏù¥ ÏóÜÏúºÎ©¥ Î°úÍπÖ ÏïàÌï®
  if (!DISCORD_LOGGING_ENABLED) {
    console.log('Discord Î°úÍπÖÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.');
    return;
  }

  // Î¥á Í∞ùÏ≤¥Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
  if (!discordBot || !EmbedBuilder) {
    console.log('Discord Î¥áÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î°úÍ∑∏Î•º Ï†ÑÏÜ°Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
    return;
  }

  try {
    // Î¥áÏù¥ Ïó∞Í≤∞ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
    if (!discordBot.isReady()) {
      console.log('Discord Î¥áÏù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Î©îÏãúÏßÄÎ•º Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    // ÏÇ¨Ïö©Ïûê Ïú†ÌòïÏóê Îî∞Îùº Ï±ÑÎÑê ID Í≤∞Ï†ï
    const userType = embedData.userType || 'store'; // Í∏∞Î≥∏Í∞íÏùÄ ÏùºÎ∞ò Îß§Ïû•
    let channelId = DISCORD_CHANNEL_ID; // Í∏∞Î≥∏ Ï±ÑÎÑê
    
    if (userType === 'agent') {
      channelId = DISCORD_AGENT_CHANNEL_ID;
      console.log('Í¥ÄÎ¶¨Ïûê Î°úÍ∑∏ Ï†ÑÏÜ° - Ï±ÑÎÑê ID:', channelId);
    } else {
      channelId = DISCORD_STORE_CHANNEL_ID;
      console.log('ÏùºÎ∞ò Îß§Ïû• Î°úÍ∑∏ Ï†ÑÏÜ° - Ï±ÑÎÑê ID:', channelId);
    }
    
    // Ï±ÑÎÑê IDÍ∞Ä ÏóÜÏúºÎ©¥ Î°úÍπÖ Ï§ëÎã®
    if (!channelId) {
      console.log(`${userType} Ïú†ÌòïÏùò Discord Ï±ÑÎÑê IDÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.`);
      return;
    }

    console.log('Discord Ï±ÑÎÑêÏóê Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÎèÑ...');
    console.log('Discord Ï±ÑÎÑê ID:', channelId);
    
    // Ï±ÑÎÑê Í∞ÄÏ†∏Ïò§Í∏∞ ÏãúÎèÑ
    let channel = null;
    try {
      channel = await discordBot.channels.fetch(channelId);
    } catch (channelError) {
      console.error(`Ï±ÑÎÑê ID ${channelId} Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:`, channelError.message);
      console.error('Ï†ÑÏ≤¥ Ïò§Î•ò:', channelError);
      return;
    }
    
    if (!channel) {
      console.error(`Ï±ÑÎÑêÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${channelId}`);
      return;
    }

    console.log(`Ï±ÑÎÑê Ï∞æÏùå: ${channel.name} (${channel.id}), Î©îÏãúÏßÄ Ï†ÑÏÜ° Ï§ë...`);
    
    try {
      // EmbedBuilder ÏÉùÏÑ±
      const embed = new EmbedBuilder()
        .setTitle(embedData.title || 'ÏïåÎ¶º')
        .setColor(embedData.color || 0x0099FF);
      
      // Fields Ï∂îÍ∞Ä
      if (embedData.fields && Array.isArray(embedData.fields)) {
        embed.addFields(...embedData.fields);
      }
      
      // ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏÑ§Ï†ï
      if (embedData.timestamp) {
        embed.setTimestamp(new Date(embedData.timestamp));
      } else {
        embed.setTimestamp();
      }
      
      // Footer ÏÑ§Ï†ï
      if (embedData.footer && embedData.footer.text) {
        embed.setFooter({ text: embedData.footer.text });
      }
      
      // Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÎèÑ
      const sentMessage = await channel.send({ embeds: [embed] });
      console.log(`Discord Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏÑ±Í≥µ! Î©îÏãúÏßÄ ID: ${sentMessage.id}`);
      return true;
    } catch (embedError) {
      console.error('Embed ÏÉùÏÑ± ÎòêÎäî Ï†ÑÏÜ° Ï§ë Ïò§Î•ò:', embedError.message);
      console.error('ÏûêÏÑ∏Ìïú Ïò§Î•ò Ï†ïÎ≥¥:', embedError);
      return false;
    }
  } catch (error) {
    console.error('Discord Î°úÍ∑∏ Ï†ÑÏÜ° Ï§ë Ïò§Î•ò:', error.message);
    console.error('ÏûêÏÑ∏Ìïú Ïò§Î•ò Ï†ïÎ≥¥:', error);
    return false;
  }
}

// ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏Ïö© ÏóîÎìúÌè¨Ïù∏Ìä∏
app.get('/', (req, res) => {
  res.json({ 
    status: 'Server is running',
    timestamp: new Date().toISOString(),
    cache: cacheUtils.status(),
    env: {
      SHEET_ID: SPREADSHEET_ID ? 'SET' : 'NOT SET',
      GOOGLE_SERVICE_ACCOUNT_EMAIL: GOOGLE_SERVICE_ACCOUNT_EMAIL ? 'SET' : 'NOT SET',
      GOOGLE_PRIVATE_KEY: GOOGLE_PRIVATE_KEY ? 'SET' : 'NOT SET',
      PORT: process.env.PORT || 4000
    }
  });
});

// Ï∫êÏãú ÏÉÅÌÉú ÌôïÏù∏Ïö© ÏóîÎìúÌè¨Ïù∏Ìä∏
app.get('/api/cache-status', (req, res) => {
  res.json({
    status: 'success',
    cache: cacheUtils.status(),
    timestamp: new Date().toISOString()
  });
});

// Ï∫êÏãú Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ® ÏóîÎìúÌè¨Ïù∏Ìä∏
app.post('/api/cache-refresh', (req, res) => {
  const { sheet } = req.body;
  
  if (sheet) {
    // ÌäπÏ†ï ÏãúÌä∏ Ï∫êÏãúÎßå ÏÇ≠Ï†ú
    cacheUtils.delete(`sheet_${sheet}`);
    res.json({
      status: 'success',
      message: `Ï∫êÏãú ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å: ${sheet}`,
      timestamp: new Date().toISOString()
    });
  } else {
    // Ï†ÑÏ≤¥ Ï∫êÏãú Ï†ïÎ¶¨
    cacheUtils.cleanup();
    res.json({
      status: 'success',
      message: 'Ï†ÑÏ≤¥ Ï∫êÏãú ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å',
      timestamp: new Date().toISOString()
    });
  }
});

// Ï£ºÏÜåÎ•º ÏúÑÎèÑ/Í≤ΩÎèÑÎ°ú Î≥ÄÌôòÌïòÏó¨ ÏãúÌä∏Ïóê ÏóÖÎç∞Ïù¥Ìä∏
app.post('/api/update-coordinates', async (req, res) => {
  try {
    console.log('Updating coordinates...');
    
    const storeValues = await getSheetValues(STORE_SHEET_NAME);
    if (!storeValues) {
      throw new Error('Failed to fetch data from store sheet');
    }

    // Ìó§Îçî Ï†úÍ±∞
    const storeRows = storeValues.slice(1);
    const updates = [];

    for (let i = 0; i < storeRows.length; i++) {
      const row = storeRows[i];
      const address = row[3]; // XÏó¥: Ï£ºÏÜå
      const status = row[4];   // DÏó¥: Í±∞ÎûòÏÉÅÌÉú
      
      if (status === "ÏÇ¨Ïö©") {
        if (!address || address.toString().trim() === '') {
          // ÏÇ¨Ïö© ÏÉÅÌÉúÏù¥ÏßÄÎßå Ï£ºÏÜåÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Ï¢åÌëú ÏÇ≠Ï†ú
          updates.push({
            range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
            values: [["", ""]]
          });
          console.log(`Cleared coordinates for store without address at row ${i + 2}`);
          continue;
        }
        
        // Ï£ºÏÜåÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ geocoding Ïã§Ìñâ
        try {
          const result = await geocodeAddress(address);
          if (result) {
            const { latitude, longitude } = result;
            updates.push({
              range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
              values: [[latitude, longitude]]
            });
            console.log(`Updated coordinates for address: ${address}`);
            console.log(`Latitude: ${latitude}, Longitude: ${longitude}`);
          } else {
            console.log(`No results found for address: ${address}`);
            // geocoding Ïã§Ìå® Ïãú Í∏∞Ï°¥ Ï¢åÌëú ÏÇ≠Ï†ú
            updates.push({
              range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
              values: [["", ""]]
            });
            console.log(`Cleared coordinates for failed geocoding at row ${i + 2}`);
          }
        } catch (error) {
          console.error(`Error geocoding address: ${address}`, error);
          // geocoding Ïò§Î•ò Ïãú Í∏∞Ï°¥ Ï¢åÌëú ÏÇ≠Ï†ú
          updates.push({
            range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
            values: [["", ""]]
          });
          console.log(`Cleared coordinates for geocoding error at row ${i + 2}`);
        }
      } else {
        // ÎØ∏ÏÇ¨Ïö© Îß§Ïû•ÏùÄ ÏúÑÎèÑ/Í≤ΩÎèÑ Í∞íÏùÑ Îπà Í∞íÏúºÎ°ú ÎπÑÏõÄ
        updates.push({
          range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
          values: [["", ""]]
        });
        console.log(`Cleared coordinates for unused store at row ${i + 2}`);
      }
      // API Ìï†ÎãπÎüâ Ï†úÌïúÏùÑ ÌîºÌïòÍ∏∞ ÏúÑÌïú ÏßÄÏó∞ (ÏÇ¨Ïö© Îß§Ïû•Îßå)
      if (status === "ÏÇ¨Ïö©") await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
    if (updates.length > 0) {
      await sheets.spreadsheets.values.batchUpdate({
        spreadsheetId: SPREADSHEET_ID,
        resource: {
          valueInputOption: 'USER_ENTERED',
          data: updates
        }
      });
      console.log(`Successfully updated ${updates.length} coordinates`);
    } else {
      console.log('No coordinates to update');
    }

    res.json({ 
      success: true, 
      message: `Updated coordinates for ${updates.length} addresses` 
    });
  } catch (error) {
    console.error('Error updating coordinates:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to update coordinates', 
      message: error.message 
    });
  }
});

// Ïä§ÌÜ†Ïñ¥ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Ï∫êÏã± Ï†ÅÏö©)
app.get('/api/stores', async (req, res) => {
  const { includeShipped = 'true' } = req.query; // ÏøºÎ¶¨ ÌååÎùºÎØ∏ÌÑ∞Î°ú Ï∂úÍ≥† Ï†úÏô∏ Ïó¨Î∂Ä Ï†úÏñ¥
  const cacheKey = `processed_stores_data_${includeShipped}`;
  
  // Ï∫êÏãúÏóêÏÑú Î®ºÏ†Ä ÌôïÏù∏
  const cachedStores = cacheUtils.get(cacheKey);
  if (cachedStores) {
    console.log('Ï∫êÏãúÎêú Îß§Ïû• Îç∞Ïù¥ÌÑ∞ Î∞òÌôò');
    return res.json(cachedStores);
  }
  
  try {
    console.log('Îß§Ïû• Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏãúÏûë...');
    const startTime = Date.now();
    
    const [inventoryValues, storeValues] = await Promise.all([
      getSheetValues(INVENTORY_SHEET_NAME),
      getSheetValues(STORE_SHEET_NAME)
    ]);
    
    if (!inventoryValues || !storeValues) {
      throw new Error('Failed to fetch data from sheets');
    }

    // Ìó§Îçî Ï†úÍ±∞ (Ï≤´ 3ÌñâÏùÄ Ï†úÏô∏)
    const inventoryRows = inventoryValues.slice(3);
    const storeRows = storeValues.slice(1);

    // Ï∂úÍ≥† Ï†úÏô∏ Î°úÏßÅ (includeShippedÍ∞Ä 'false'Ïùº ÎïåÎßå Ï†ÅÏö©)
    let threeDaysAgo = null;
    if (includeShipped === 'false') {
      const today = new Date();
      threeDaysAgo = new Date(today);
      threeDaysAgo.setDate(today.getDate() - 3);
    }

    // Îß§Ïû•Î≥Ñ Ïû¨Í≥† Îç∞Ïù¥ÌÑ∞ Îß§Ìïë
    const inventoryMap = {};
    
    inventoryRows.forEach((row, index) => {
      if (!row || row.length < 15) return; // ÏµúÏÜå OÏó¥ÍπåÏßÄ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏñ¥Ïïº Ìï®
      
      const storeName = (row[13] || '').toString().trim();  // NÏó¥: Îß§Ïû•Î™Ö
      const model = (row[5] || '').toString().trim();      // FÏó¥: Î™®Îç∏
      const color = (row[6] || '').toString().trim();      // GÏó¥: ÏÉâÏÉÅ
      const status = (row[7] || '').toString().trim();     // HÏó¥: ÏÉÅÌÉú (Ï†ïÏÉÅ, Ïù¥Î†•, Î∂àÎüâ)
      const type = (row[4] || '').toString().trim();       // EÏó¥: Ï¢ÖÎ•ò (Îã®ÎßêÍ∏∞, Ïõ®Ïñ¥Îü¨Î∏î, Ïä§ÎßàÌä∏Í∏∞Í∏∞, Ïú†Ïã¨)
      const shippingDate = row[14] ? new Date(row[14]) : null;  // OÏó¥: Ï∂úÍ≥†Ïùº
      
      if (!storeName || !model || !color) return;

      // Ï∂úÍ≥†ÏùºÏù¥ ÏûàÍ≥†, ÏµúÍ∑º 3Ïùº Ïù¥ÎÇ¥Ïù∏ Í≤ΩÏö∞ Ïû¨Í≥†ÏóêÏÑú Ï†úÏô∏ (includeShippedÍ∞Ä 'false'Ïùº ÎïåÎßå)
      if (includeShipped === 'false' && shippingDate && threeDaysAgo && shippingDate >= threeDaysAgo) return;

      // Îß§Ïû•Î≥Ñ Ïû¨Í≥† Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ ÏÉùÏÑ±
      if (!inventoryMap[storeName]) {
        inventoryMap[storeName] = {
          phones: {},    // Îã®ÎßêÍ∏∞
          sims: {},      // Ïú†Ïã¨
          wearables: {}, // Ïõ®Ïñ¥Îü¨Î∏î
          smartDevices: {} // Ïä§ÎßàÌä∏Í∏∞Í∏∞
        };
      }
      
      // Ï¢ÖÎ•òÏóê Îî∞Îùº Î∂ÑÎ•ò
      let category = 'phones'; // Í∏∞Î≥∏Í∞í
      if (type === 'Ïú†Ïã¨') {
        category = 'sims';
      } else if (type === 'Ïõ®Ïñ¥Îü¨Î∏î') {
        category = 'wearables';
      } else if (type === 'Ïä§ÎßàÌä∏Í∏∞Í∏∞') {
        category = 'smartDevices';
      }
      
      if (!inventoryMap[storeName][category][model]) {
        inventoryMap[storeName][category][model] = {};
      }
      
      // ÏÉÅÌÉúÎ≥ÑÎ°ú ÏàòÎüâ Í¥ÄÎ¶¨
      if (!inventoryMap[storeName][category][model][status]) {
        inventoryMap[storeName][category][model][status] = {};
      }
      
      // Í∞ôÏùÄ Î™®Îç∏/ÏÉâÏÉÅ/ÏÉÅÌÉú Ï°∞Ìï©Ïùò ÏàòÎüâÏùÑ Ï¶ùÍ∞Ä
      if (!inventoryMap[storeName][category][model][status][color]) {
        inventoryMap[storeName][category][model][status][color] = 1;
      } else {
        inventoryMap[storeName][category][model][status][color]++;
      }
    });

    // Îß§Ïû• Ï†ïÎ≥¥ÏôÄ Ïû¨Í≥† Ï†ïÎ≥¥ Í≤∞Ìï©
    const stores = storeRows
      .filter(row => {
        const name = (row[6] || '').toString().trim();  // FÏó¥: ÏóÖÏ≤¥Î™Ö
        const status = row[4];                          // DÏó¥: Í±∞ÎûòÏÉÅÌÉú
        return name && status === "ÏÇ¨Ïö©";
      })
      .map(row => {
        const latitude = parseFloat(row[0] || '0');    // AÏó¥: ÏúÑÎèÑ
        const longitude = parseFloat(row[1] || '0');   // BÏó¥: Í≤ΩÎèÑ
        const status = row[4];                         // DÏó¥: Í±∞ÎûòÏÉÅÌÉú
        const name = row[6].toString().trim();         // FÏó¥: ÏóÖÏ≤¥Î™Ö
        const storeId = row[7];                        // GÏó¥: Îß§Ïû• ID
        const phone = row[9] || '';                    // IÏó¥: Ïó∞ÎùΩÏ≤ò
        const manager = row[13] || '';                 // MÏó¥: Îã¥ÎãπÏûê
        const address = (row[3] || '').toString();    // XÏó¥: Ï£ºÏÜå
        
        // Îπà Îß§Ïû• ID Ï†úÏô∏
        if (!storeId || storeId.toString().trim() === '') {
          return null;
        }

        const inventory = inventoryMap[name] || {};

        return {
          id: storeId.toString(),
          name,
          address,
          phone,
          manager,
          latitude,
          longitude,
          uniqueId: `${storeId}_${name}`,
          inventory: inventory
        };
      })
      .filter(store => store !== null); // null Í∞í Ï†úÍ±∞

    const processingTime = Date.now() - startTime;
    console.log(`Îß§Ïû• Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏôÑÎ£å: ${stores.length}Í∞ú Îß§Ïû•, ${processingTime}ms ÏÜåÏöî`);
    
    // Ï∫êÏãúÏóê Ï†ÄÏû• (5Î∂Ñ TTL)
    cacheUtils.set(cacheKey, stores);
    
    res.json(stores);
  } catch (error) {
    console.error('Error fetching store data:', error);
    res.status(500).json({ 
      error: 'Failed to fetch store data', 
      message: error.message 
    });
  }
});

// Î™®Îç∏Í≥º ÏÉâÏÉÅ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (Ï∫êÏã± Ï†ÅÏö©)
app.get('/api/models', async (req, res) => {
  const cacheKey = 'processed_models_data';
  
  // Ï∫êÏãúÏóêÏÑú Î®ºÏ†Ä ÌôïÏù∏
  const cachedModels = cacheUtils.get(cacheKey);
  if (cachedModels) {
    console.log('Ï∫êÏãúÎêú Î™®Îç∏ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò');
    return res.json(cachedModels);
  }
  
  try {
    console.log('Î™®Îç∏ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏãúÏûë...');
    const startTime = Date.now();
    
    const inventoryValues = await getSheetValues(INVENTORY_SHEET_NAME);
    
    if (!inventoryValues) {
      throw new Error('Failed to fetch data from inventory sheet');
    }

    // Ìó§Îçî Ï†úÍ±∞ (Ï≤´ 3ÌñâÏùÄ Ï†úÏô∏)
    const inventoryRows = inventoryValues.slice(3);

    // Î™®Îç∏Í≥º ÏÉâÏÉÅ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
    const modelColorMap = {};
    
    inventoryRows.forEach(row => {
      if (row.length < 8) return;
      
      const model = (row[5] || '').toString().trim();    // FÏó¥: Î™®Îç∏
      const color = (row[6] || '').toString().trim();    // GÏó¥: ÏÉâÏÉÅ
      const status = (row[7] || '').toString().trim();   // HÏó¥: ÏÉÅÌÉú
      const type = (row[4] || '').toString().trim();     // EÏó¥: Ï¢ÖÎ•ò
      
      if (!model || !color) return;
      
      // ÏÉÅÌÉúÍ∞Ä 'Ï†ïÏÉÅ'Ïù∏ Í≤ÉÎßå Ìè¨Ìï® (ÌïÑÌÑ∞ÎßÅ)
      if (status !== 'Ï†ïÏÉÅ') return;
      
      if (!modelColorMap[model]) {
        modelColorMap[model] = new Set();
      }
      modelColorMap[model].add(color);
    });

    // SetÏùÑ Î∞∞Ïó¥Î°ú Î≥ÄÌôò
    const result = Object.entries(modelColorMap).reduce((acc, [model, colors]) => {
      acc[model] = Array.from(colors).sort();
      return acc;
    }, {});

    const processingTime = Date.now() - startTime;
    console.log(`Î™®Îç∏ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏôÑÎ£å: ${Object.keys(result).length}Í∞ú Î™®Îç∏, ${processingTime}ms ÏÜåÏöî`);
    
    // Ï∫êÏãúÏóê Ï†ÄÏû• (5Î∂Ñ TTL)
    cacheUtils.set(cacheKey, result);
    
    res.json(result);
  } catch (error) {
    console.error('Error fetching model and color data:', error);
    res.status(500).json({ 
      error: 'Failed to fetch model and color data', 
      message: error.message 
    });
  }
});

// ÎåÄÎ¶¨Ï†ê ID Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (Ï∫êÏã± Ï†ÅÏö©)
app.get('/api/agents', async (req, res) => {
  const cacheKey = 'processed_agents_data';
  
  // Ï∫êÏãúÏóêÏÑú Î®ºÏ†Ä ÌôïÏù∏
  const cachedAgents = cacheUtils.get(cacheKey);
  if (cachedAgents) {
    console.log('Ï∫êÏãúÎêú ÎåÄÎ¶¨Ï†ê Îç∞Ïù¥ÌÑ∞ Î∞òÌôò');
    return res.json(cachedAgents);
  }
  
  try {
    console.log('ÎåÄÎ¶¨Ï†ê Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏãúÏûë...');
    const startTime = Date.now();
    
    const agentValues = await getSheetValues(AGENT_SHEET_NAME);
    
    if (!agentValues) {
      throw new Error('Failed to fetch data from agent sheet');
    }

    // Ìó§Îçî Ï†úÍ±∞
    const agentRows = agentValues.slice(1);
    
    // ÎåÄÎ¶¨Ï†ê Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
    const agents = agentRows.map(row => {
      return {
        target: row[0] || '',       // AÏó¥: ÎåÄÏÉÅ
        qualification: row[1] || '', // BÏó¥: ÏûêÍ≤©
        contactId: row[2] || ''      // CÏó¥: Ïó∞ÎùΩÏ≤ò(ÏïÑÏù¥Îîî)
      };
    }).filter(agent => agent.contactId); // ÏïÑÏù¥ÎîîÍ∞Ä ÏûàÎäî Ìï≠Î™©Îßå ÌïÑÌÑ∞ÎßÅ
    
    const processingTime = Date.now() - startTime;
    console.log(`ÎåÄÎ¶¨Ï†ê Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ ÏôÑÎ£å: ${agents.length}Í∞ú ÎåÄÎ¶¨Ï†ê, ${processingTime}ms ÏÜåÏöî`);
    
    // Ï∫êÏãúÏóê Ï†ÄÏû• (5Î∂Ñ TTL)
    cacheUtils.set(cacheKey, agents);
    
    res.json(agents);
  } catch (error) {
    console.error('Error fetching agent data:', error);
    res.status(500).json({ 
      error: 'Failed to fetch agent data', 
      message: error.message 
    });
  }
});

// ÏÇ¨Ïö©Ïûê ÌôúÎèô Î°úÍπÖ API (ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨)
app.post('/api/log-activity', async (req, res) => {
  // Ï¶âÏãú ÏùëÎãµ Î∞òÌôò
  res.json({ success: true });
  
  // Î°úÍπÖ Ï≤òÎ¶¨Î•º ÎπÑÎèôÍ∏∞Î°ú Ïã§Ìñâ
  setImmediate(async () => {
    try {
      const { 
        userId, 
        userType, 
        targetName, 
        ipAddress, 
        location, 
        deviceInfo, 
        activity, 
        model, 
        colorName,
        callButton 
      } = req.body;
      
      // ÌôúÎèô Ïú†ÌòïÏóê Îî∞Î•∏ Ï†úÎ™© ÏÑ§Ï†ï
      let title = 'ÏÇ¨Ïö©Ïûê ÌôúÎèô';
      let embedColor = 3447003; // ÌååÎûÄÏÉâ
      
      if (activity === 'login') {
        title = 'ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏';
        embedColor = 5763719; // Ï¥àÎ°ùÏÉâ
      } else if (activity === 'search') {
        title = 'Î™®Îç∏ Í≤ÄÏÉâ';
        embedColor = 16776960; // ÎÖ∏ÎûÄÏÉâ
      } else if (activity === 'call_button') {
        title = 'Ï†ÑÌôî Ïó∞Í≤∞ Î≤ÑÌäº ÌÅ¥Î¶≠';
        embedColor = 15548997; // Îπ®Í∞ÑÏÉâ
      } else if (activity === 'kakao_button') {
        title = 'Ïπ¥ÌÜ°Î¨∏Íµ¨ ÏÉùÏÑ±';
        embedColor = 16776960; // ÎÖ∏ÎûÄÏÉâ (Ïπ¥Ïπ¥Ïò§ÌÜ° ÏÉâÏÉÅ)
      }
      
      // DiscordÎ°ú Î°úÍ∑∏ Ï†ÑÏÜ° ÏãúÎèÑ
      if (DISCORD_LOGGING_ENABLED) {
        try {
          // Embed Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
          const embedData = {
            title: title,
            color: embedColor,
            timestamp: new Date().toISOString(),
            userType: userType || 'store',
            fields: [
              {
                name: 'ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥',
                value: `ID: ${userId}\nÏ¢ÖÎ•ò: ${userType === 'agent' ? 'Í¥ÄÎ¶¨Ïûê' : 'ÏùºÎ∞ò'}\nÎåÄÏÉÅ: ${targetName || 'ÏóÜÏùå'}`
              },
              {
                name: 'Ï†ëÏÜç Ï†ïÎ≥¥',
                value: `IP: ${ipAddress}\nÏúÑÏπò: ${location || 'Ïïå Ïàò ÏóÜÏùå'}\nÍ∏∞Í∏∞: ${deviceInfo || 'Ïïå Ïàò ÏóÜÏùå'}`
              }
            ],
            footer: {
              text: userType === 'agent' ? 'VIP+ Í¥ÄÎ¶¨Ïûê ÌôúÎèô Î°úÍ∑∏' : 'VIP+ Îß§Ïû• ÌôúÎèô Î°úÍ∑∏'
            }
          };
          
          // Í≤ÄÏÉâ Ï†ïÎ≥¥Í∞Ä ÏûàÎäî Í≤ΩÏö∞ ÌïÑÎìú Ï∂îÍ∞Ä
          if (model) {
            embedData.fields.push({
              name: 'Í≤ÄÏÉâ Ï†ïÎ≥¥',
              value: `Î™®Îç∏: ${model}${colorName ? `\nÏÉâÏÉÅ: ${colorName}` : ''}`
            });
          }
          
          // Ï†ÑÌôî Ïó∞Í≤∞ Î≤ÑÌäº ÌÅ¥Î¶≠ Ï†ïÎ≥¥
          if (callButton) {
            embedData.fields.push({
              name: 'Ï†ÑÌôî Ïó∞Í≤∞',
              value: `${callButton}`
            });
          }
          
          // Ïπ¥ÌÜ°Î¨∏Íµ¨ ÏÉùÏÑ± Î≤ÑÌäº ÌÅ¥Î¶≠ Ï†ïÎ≥¥
          if (req.body.kakaoButton) {
            embedData.fields.push({
              name: 'Ïπ¥ÌÜ°Î¨∏Íµ¨ ÏÉùÏÑ±',
              value: `Ïπ¥Ïπ¥Ïò§ÌÜ° Î©îÏãúÏßÄ ÌÖúÌîåÎ¶øÏù¥ ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§.`
            });
          }
          
          // DiscordÎ°ú Î°úÍ∑∏ Ï†ÑÏÜ°
          await sendLogToDiscord(embedData);
        } catch (logError) {
          console.error('ÌôúÎèô Î°úÍ∑∏ Discord Ï†ÑÏÜ° Ïò§Î•ò:', logError.message);
        }
      }
    } catch (error) {
      console.error('ÌôúÎèô Î°úÍ∑∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:', error);
    }
  });
});

// Î°úÍ∑∏Ïù∏ Í≤ÄÏ¶ù API Ï∂îÍ∞Ä
app.post('/api/login', async (req, res) => {
  try {
    const { storeId, deviceInfo, ipAddress, location } = req.body;
    
    if (!storeId) {
      return res.status(400).json({ 
        success: false, 
        error: 'Store ID is required' 
      });
    }
    
    console.log(`Login attempt with ID: ${storeId}`);
    console.log('Step 1: Starting login process...');
    
    // Ïû¨Í≥†Î™®Îìú Ï†ÑÏö© ID Î™©Î°ù
    const INVENTORY_MODE_IDS = ["JEGO306891", "JEGO315835", "JEGO314942", "JEGO316558", "JEGO316254"];
    
    // Ïû¨Í≥†Î™®Îìú IDÏù∏ÏßÄ Î®ºÏ†Ä ÌôïÏù∏
    if (INVENTORY_MODE_IDS.includes(storeId)) {
      console.log(`Step 1.5: Inventory mode ID detected: ${storeId}`);
      
      // ÎîîÏä§ÏΩîÎìúÎ°ú Î°úÍ∑∏Ïù∏ Î°úÍ∑∏ Ï†ÑÏÜ°
      if (DISCORD_LOGGING_ENABLED) {
        try {
          const embedData = {
            title: 'Ïû¨Í≥†Î™®Îìú Î°úÍ∑∏Ïù∏',
            color: 16776960, // ÎÖ∏ÎûÄÏÉâ
            timestamp: new Date().toISOString(),
            userType: 'inventory', // Ïû¨Í≥†Î™®Îìú ÌÉÄÏûÖ ÏßÄÏ†ï
            fields: [
              {
                name: 'Ïû¨Í≥†Î™®Îìú Ï†ïÎ≥¥',
                value: `ID: ${storeId}\nÎ™®Îìú: Ïû¨Í≥†Í¥ÄÎ¶¨ Ï†ÑÏö©`
              },
              {
                name: 'Ï†ëÏÜç Ï†ïÎ≥¥',
                value: `IP: ${ipAddress || 'Ïïå Ïàò ÏóÜÏùå'}\nÏúÑÏπò: ${location || 'Ïïå Ïàò ÏóÜÏùå'}\nÍ∏∞Í∏∞: ${deviceInfo || 'Ïïå Ïàò ÏóÜÏùå'}`
              }
            ],
            footer: {
              text: 'VIP+ Ïû¨Í≥†Î™®Îìú Î°úÍ∑∏Ïù∏'
            }
          };
          
          await sendLogToDiscord(embedData);
        } catch (logError) {
          console.error('Ïû¨Í≥†Î™®Îìú Î°úÍ∑∏Ïù∏ Î°úÍ∑∏ Ï†ÑÏÜ° Ïã§Ìå®:', logError.message);
        }
      }
      
      console.log('Step 1.6: Inventory mode login successful, sending response...');
      return res.json({
        success: true,
        isAgent: false,
        isInventory: true,
        storeInfo: {
          id: storeId,
          name: 'Ïû¨Í≥†Í¥ÄÎ¶¨ Î™®Îìú',
          manager: 'Ïû¨Í≥†Í¥ÄÎ¶¨Ïûê',
          address: '',
          latitude: 37.5665,
          longitude: 126.9780,
          phone: ''
        }
      });
    }
    
    // 1. Î®ºÏ†Ä ÎåÄÎ¶¨Ï†ê Í¥ÄÎ¶¨Ïûê IDÏù∏ÏßÄ ÌôïÏù∏
    console.log('Step 2: Checking if ID is agent...');
    const agentValues = await getSheetValues(AGENT_SHEET_NAME);
    console.log('Step 3: Agent sheet data fetched, rows:', agentValues ? agentValues.length : 0);
    
    if (agentValues) {
      const agentRows = agentValues.slice(1);
      console.log('Step 4: Agent rows (excluding header):', agentRows.length);
      
      const agent = agentRows.find(row => row[2] === storeId); // CÏó¥: Ïó∞ÎùΩÏ≤ò(ÏïÑÏù¥Îîî)
      console.log('Step 5: Agent search result:', agent ? 'Found' : 'Not found');
      
      if (agent) {
        console.log(`Found agent: ${agent[0]}, ${agent[1]}`);
        console.log('Step 6: Processing agent login...');
        
        // ÎîîÏä§ÏΩîÎìúÎ°ú Î°úÍ∑∏Ïù∏ Î°úÍ∑∏ Ï†ÑÏÜ°
        if (DISCORD_LOGGING_ENABLED) {
          try {
            const embedData = {
              title: 'Í¥ÄÎ¶¨Ïûê Î°úÍ∑∏Ïù∏',
              color: 15844367, // Î≥¥ÎùºÏÉâ
              timestamp: new Date().toISOString(),
              userType: 'agent', // Í¥ÄÎ¶¨Ïûê ÌÉÄÏûÖ ÏßÄÏ†ï
              fields: [
                {
                  name: 'Í¥ÄÎ¶¨Ïûê Ï†ïÎ≥¥',
                  value: `ID: ${agent[2]}\nÎåÄÏÉÅ: ${agent[0]}\nÏûêÍ≤©: ${agent[1]}`
                },
                {
                  name: 'Ï†ëÏÜç Ï†ïÎ≥¥',
                  value: `IP: ${ipAddress || 'Ïïå Ïàò ÏóÜÏùå'}\nÏúÑÏπò: ${location || 'Ïïå Ïàò ÏóÜÏùå'}\nÍ∏∞Í∏∞: ${deviceInfo || 'Ïïå Ïàò ÏóÜÏùå'}`
                }
              ],
              footer: {
                text: 'VIP+ Í¥ÄÎ¶¨Ïûê Î°úÍ∑∏Ïù∏'
              }
            };
            
            await sendLogToDiscord(embedData);
          } catch (logError) {
            console.error('Î°úÍ∑∏Ïù∏ Î°úÍ∑∏ Ï†ÑÏÜ° Ïã§Ìå®:', logError.message);
            // Î°úÍ∑∏ Ï†ÑÏÜ° Ïã§Ìå®Ìï¥ÎèÑ Î°úÍ∑∏Ïù∏ÏùÄ ÌóàÏö©
          }
        }
        
        console.log('Step 7: Agent login successful, sending response...');
        return res.json({
          success: true,
          isAgent: true,
          agentInfo: {
            target: agent[0] || '',       // AÏó¥: ÎåÄÏÉÅ
            qualification: agent[1] || '', // BÏó¥: ÏûêÍ≤©
            contactId: agent[2] || ''      // CÏó¥: Ïó∞ÎùΩÏ≤ò(ÏïÑÏù¥Îîî)
          }
        });
      }
    }
    
    // 2. ÎåÄÎ¶¨Ï†ê Í¥ÄÎ¶¨ÏûêÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ ÏùºÎ∞ò Îß§Ïû•ÏúºÎ°ú Í≤ÄÏÉâ
    console.log('Step 8: Not an agent, checking if ID is store...');
    const storeValues = await getSheetValues(STORE_SHEET_NAME);
    console.log('Step 9: Store sheet data fetched, rows:', storeValues ? storeValues.length : 0);
    
    if (!storeValues) {
      console.log('Step 9.5: Store sheet data is null or empty');
      throw new Error('Failed to fetch data from store sheet');
    }
    
    const storeRows = storeValues.slice(1);
    console.log('Step 10: Store rows (excluding header):', storeRows.length);
    
    // Îß§Ïû• ID Í≤ÄÏÉâÏùÑ ÏúÑÌïú ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
    console.log('Step 10.5: Searching for store ID:', storeId);
    console.log('Step 10.6: First few store IDs for comparison:');
    storeRows.slice(0, 5).forEach((row, index) => {
      console.log(`  Row ${index + 1}: "${row[7]}" (type: ${typeof row[7]})`);
    });
    
    const foundStoreRow = storeRows.find(row => {
      const rowId = row[7];
      const match = rowId === storeId;
      if (match) {
        console.log(`Step 10.7: Found matching store ID: "${rowId}"`);
      }
      return match;
    }); // GÏó¥: Îß§Ïû• IDÎ°ú ÏàòÏ†ï
    console.log('Step 11: Store search result:', foundStoreRow ? 'Found' : 'Not found');
    
    if (foundStoreRow) {
      const store = {
        id: foundStoreRow[7],                      // GÏó¥: Îß§Ïû• ID
        name: foundStoreRow[6],                    // FÏó¥: ÏóÖÏ≤¥Î™Ö
        manager: foundStoreRow[13] || '',          // MÏó¥: Îã¥ÎãπÏûê
        address: foundStoreRow[3] || '',          // XÏó¥: Ï£ºÏÜå
        latitude: parseFloat(foundStoreRow[0] || '0'),  // AÏó¥: ÏúÑÎèÑ
        longitude: parseFloat(foundStoreRow[1] || '0'),  // BÏó¥: Í≤ΩÎèÑ
        phone: foundStoreRow[11] || ''              // IÏó¥: Ïó∞ÎùΩÏ≤ò Ï∂îÍ∞Ä
      };
      
      console.log(`Found store: ${store.name}`);
      console.log('Step 12: Processing store login...');
      
      // ÎîîÏä§ÏΩîÎìúÎ°ú Î°úÍ∑∏Ïù∏ Î°úÍ∑∏ Ï†ÑÏÜ°
      if (DISCORD_LOGGING_ENABLED) {
        try {
          const embedData = {
            title: 'Îß§Ïû• Î°úÍ∑∏Ïù∏',
            color: 5763719, // Ï¥àÎ°ùÏÉâ
            timestamp: new Date().toISOString(),
            userType: 'store', // ÏùºÎ∞ò Îß§Ïû• ÌÉÄÏûÖ ÏßÄÏ†ï
            fields: [
              {
                name: 'Îß§Ïû• Ï†ïÎ≥¥',
                value: `ID: ${store.id}\nÎß§Ïû•Î™Ö: ${store.name}\nÎã¥ÎãπÏûê: ${store.manager || 'ÏóÜÏùå'}`
              },
              {
                name: 'Ï†ëÏÜç Ï†ïÎ≥¥',
                value: `IP: ${ipAddress || 'Ïïå Ïàò ÏóÜÏùå'}\nÏúÑÏπò: ${location || 'Ïïå Ïàò ÏóÜÏùå'}\nÍ∏∞Í∏∞: ${deviceInfo || 'Ïïå Ïàò ÏóÜÏùå'}`
              }
            ],
            footer: {
              text: 'VIP+ Îß§Ïû• Î°úÍ∑∏Ïù∏'
            }
          };
          
          await sendLogToDiscord(embedData);
        } catch (logError) {
          console.error('Î°úÍ∑∏Ïù∏ Î°úÍ∑∏ Ï†ÑÏÜ° Ïã§Ìå®:', logError.message);
          // Î°úÍ∑∏ Ï†ÑÏÜ° Ïã§Ìå®Ìï¥ÎèÑ Î°úÍ∑∏Ïù∏ÏùÄ ÌóàÏö©
        }
      }
      
      console.log('Step 13: Store login successful, sending response...');
      return res.json({
        success: true,
        isAgent: false,
        storeInfo: store
      });
    }
    
    // 3. Îß§Ïû• IDÎèÑ ÏïÑÎãå Í≤ΩÏö∞
    console.log('Step 14: ID not found in either agent or store sheets');
    return res.status(404).json({
      success: false,
      error: 'Store not found'
    });
    
  } catch (error) {
    console.error('Error in login:', error);
    console.error('Login error stack:', error.stack);
    res.status(500).json({ 
      success: false, 
      error: 'Login failed', 
      message: error.message 
    });
  }
});

// Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏Î•º ÌôïÏù∏ÌïòÍ≥† Ïã§ÌñâÌïòÎäî Ìï®Ïàò
async function checkAndUpdateAddresses() {
  try {
    console.log('Checking for addresses that need updating...');
    
    const storeValues = await getSheetValues(STORE_SHEET_NAME);
    if (!storeValues) {
      throw new Error('Failed to fetch data from store sheet');
    }

    // Ìó§Îçî Ï†úÍ±∞
    const storeRows = storeValues.slice(1);
    const updates = [];
    
    // Î™®Îì† Ï£ºÏÜåÏóê ÎåÄÌï¥ Ï¢åÌëú ÏóÖÎç∞Ïù¥Ìä∏ (Ìñâ ÏúÑÏπòÍ∞Ä Î≥ÄÍ≤ΩÎêòÏñ¥ÎèÑ Ìï≠ÏÉÅ Ï≤òÎ¶¨)
    for (let i = 0; i < storeRows.length; i++) {
      const row = storeRows[i];
      const address = row[3];  // XÏó¥: Ï£ºÏÜå
      const status = row[4];    // DÏó¥: Í±∞ÎûòÏÉÅÌÉú
      
      if (status === "ÏÇ¨Ïö©") {
        if (!address || address.toString().trim() === '') {
          // ÏÇ¨Ïö© ÏÉÅÌÉúÏù¥ÏßÄÎßå Ï£ºÏÜåÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Ï¢åÌëú ÏÇ≠Ï†ú
          updates.push({
            range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
            values: [["", ""]]
          });
          console.log(`Cleared coordinates for store without address at row ${i + 2}`);
          continue;
        }
        
        // Ï£ºÏÜåÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ geocoding Ïã§Ìñâ
        try {
          const result = await geocodeAddress(address);
          if (result) {
            const { latitude, longitude } = result;
            updates.push({
              range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
              values: [[latitude, longitude]]
            });
            console.log(`Updated coordinates for address: ${address}`);
            console.log(`Latitude: ${latitude}, Longitude: ${longitude}`);
          } else {
            console.log(`No results found for address: ${address}`);
            // geocoding Ïã§Ìå® Ïãú Í∏∞Ï°¥ Ï¢åÌëú ÏÇ≠Ï†ú
            updates.push({
              range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
              values: [["", ""]]
            });
            console.log(`Cleared coordinates for failed geocoding at row ${i + 2}`);
          }
        } catch (error) {
          console.error(`Error geocoding address: ${address}`, error);
          // geocoding Ïò§Î•ò Ïãú Í∏∞Ï°¥ Ï¢åÌëú ÏÇ≠Ï†ú
          updates.push({
            range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
            values: [["", ""]]
          });
          console.log(`Cleared coordinates for geocoding error at row ${i + 2}`);
        }
      } else {
        // ÎØ∏ÏÇ¨Ïö© Îß§Ïû•ÏùÄ ÏúÑÎèÑ/Í≤ΩÎèÑ Í∞íÏùÑ Îπà Í∞íÏúºÎ°ú ÎπÑÏõÄ
        updates.push({
          range: `${STORE_SHEET_NAME}!A${i + 2}:B${i + 2}`,
          values: [["", ""]]
        });
        console.log(`Cleared coordinates for unused store at row ${i + 2}`);
      }
      // API Ìï†ÎãπÎüâ Ï†úÌïúÏùÑ ÌîºÌïòÍ∏∞ ÏúÑÌïú ÏßÄÏó∞ (ÏÇ¨Ïö© Îß§Ïû•Îßå)
      if (status === "ÏÇ¨Ïö©") await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
    if (updates.length > 0) {
      await sheets.spreadsheets.values.batchUpdate({
        spreadsheetId: SPREADSHEET_ID,
        resource: {
          valueInputOption: 'USER_ENTERED',
          data: updates
        }
      });
      console.log(`Successfully updated ${updates.length} coordinates`);
    } else {
      console.log('No coordinates to update');
    }
  } catch (error) {
    console.error('Error in checkAndUpdateAddresses:', error);
  }
}

// ÏÑúÎ≤Ñ ÏãúÏûë
const server = app.listen(port, '0.0.0.0', async () => {
  try {
    console.log(`ÏÑúÎ≤ÑÍ∞Ä Ìè¨Ìä∏ ${port}ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§`);
    
    // ÌôòÍ≤ΩÎ≥ÄÏàò ÎîîÎ≤ÑÍπÖ (ÎØºÍ∞êÌïú Ï†ïÎ≥¥Îäî Î°úÍπÖÌïòÏßÄ ÏïäÏùå)
    console.log('Discord Î¥á ÌôòÍ≤ΩÎ≥ÄÏàò ÏÉÅÌÉú:');
    console.log('- DISCORD_BOT_TOKEN ÏÑ§Ï†ïÎê®:', !!process.env.DISCORD_BOT_TOKEN);
    console.log('- DISCORD_CHANNEL_ID ÏÑ§Ï†ïÎê®:', !!process.env.DISCORD_CHANNEL_ID);
    console.log('- DISCORD_AGENT_CHANNEL_ID ÏÑ§Ï†ïÎê®:', !!process.env.DISCORD_AGENT_CHANNEL_ID);
    console.log('- DISCORD_STORE_CHANNEL_ID ÏÑ§Ï†ïÎê®:', !!process.env.DISCORD_STORE_CHANNEL_ID);
    console.log('- DISCORD_LOGGING_ENABLED ÏÑ§Ï†ïÎê®:', process.env.DISCORD_LOGGING_ENABLED);
    
    // Î¨¥Î£å Geocoding ÏÑúÎπÑÏä§ ÏÉÅÌÉú
    console.log('Î¨¥Î£å Geocoding ÏÑúÎπÑÏä§ ÏÉÅÌÉú:');
    console.log('- Photon API (Komoot): ÏÇ¨Ïö© Í∞ÄÎä• (Î¨¥Î£å)');
    console.log('- Nominatim API (OpenStreetMap): ÏÇ¨Ïö© Í∞ÄÎä• (Î¨¥Î£å)');
    console.log('- Pelias API (Mapzen): ÏÇ¨Ïö© Í∞ÄÎä• (Î¨¥Î£å)');
    console.log('- Ï¥ù 3Í∞ú Î¨¥Î£å ÏÑúÎπÑÏä§Î°ú Ï†ïÌôïÎèÑ Ìñ•ÏÉÅ');
    
    // Î¥á Î°úÍ∑∏Ïù∏ (ÏÑúÎ≤Ñ ÏãúÏûë ÌõÑ)
    if (DISCORD_LOGGING_ENABLED && DISCORD_BOT_TOKEN && discordBot) {
      console.log('ÏÑúÎ≤Ñ ÏãúÏûë ÌõÑ Discord Î¥á Î°úÍ∑∏Ïù∏ ÏãúÎèÑ...');
      try {
        await discordBot.login(DISCORD_BOT_TOKEN);
        console.log('Discord Î¥á Ïó∞Í≤∞ ÏÑ±Í≥µ!');
        
        // Í¥ÄÎ¶¨Ïûê Ï±ÑÎÑê Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
        if (DISCORD_AGENT_CHANNEL_ID) {
          try {
            const agentChannel = await discordBot.channels.fetch(DISCORD_AGENT_CHANNEL_ID);
            if (agentChannel) {
              console.log(`Í¥ÄÎ¶¨Ïûê Ï±ÑÎÑê '${agentChannel.name}' Ïó∞Í≤∞ ÏÑ±Í≥µ!`);
            }
          } catch (agentChannelError) {
            console.error('Í¥ÄÎ¶¨Ïûê Ï±ÑÎÑê Ïó∞Í≤∞ Ïã§Ìå®:', agentChannelError.message);
          }
        }
        
        // ÏùºÎ∞ò Îß§Ïû• Ï±ÑÎÑê Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
        if (DISCORD_STORE_CHANNEL_ID) {
          try {
            const storeChannel = await discordBot.channels.fetch(DISCORD_STORE_CHANNEL_ID);
            if (storeChannel) {
              console.log(`ÏùºÎ∞ò Îß§Ïû• Ï±ÑÎÑê '${storeChannel.name}' Ïó∞Í≤∞ ÏÑ±Í≥µ!`);
            }
          } catch (storeChannelError) {
            console.error('ÏùºÎ∞ò Îß§Ïû• Ï±ÑÎÑê Ïó∞Í≤∞ Ïã§Ìå®:', storeChannelError.message);
          }
        }
        
        // ÌÖåÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ° (Í∏∞Î≥∏ Ï±ÑÎÑê)
        if (DISCORD_CHANNEL_ID) {
          const channel = await discordBot.channels.fetch(DISCORD_CHANNEL_ID);
          if (channel) {
            console.log(`Ï±ÑÎÑê '${channel.name}' Ïó∞Í≤∞ ÏÑ±Í≥µ!`);
            
            // ÌÖåÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
            const testEmbed = new EmbedBuilder()
              .setTitle('ÏÑúÎ≤Ñ ÏãúÏûë ÏïåÎ¶º')
              .setColor(5763719)
              .setDescription('ÏÑúÎ≤ÑÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.')
              .setTimestamp()
              .setFooter({ text: 'VIP+ ÏÑúÎ≤Ñ' });
              
            await channel.send({ embeds: [testEmbed] });
            console.log('ÏÑúÎ≤Ñ ÏãúÏûë ÏïåÎ¶º Î©îÏãúÏßÄ Ï†ÑÏÜ°Îê®');
          }
        }
      } catch (error) {
        console.error('ÏÑúÎ≤Ñ ÏãúÏûë Ïãú Discord Î¥á Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error.message);
        console.error('Discord Î¥áÏùÄ ÎπÑÌôúÏÑ±Ìôî ÏÉÅÌÉúÎ°ú ÏÑúÎ≤ÑÍ∞Ä Í≥ÑÏÜç Ïã§ÌñâÎê©ÎãàÎã§.');
      }
    } else {
      console.log('Discord Î¥á Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÍ±∞ÎÇò ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    }
    
    // Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò Ìò∏Ï∂ú
    console.log('Î™®Îì† ÏÇ¨Ïö© Ï§ëÏù∏ Ï£ºÏÜåÏóê ÎåÄÌï¥ ÏúÑÎèÑ/Í≤ΩÎèÑ Í∞íÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§...');
    await checkAndUpdateAddresses();
    
    // Îß§ ÏãúÍ∞ÑÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏ Ï≤¥ÌÅ¨ Ïã§Ìñâ (3600000ms = 1ÏãúÍ∞Ñ)
    setInterval(checkAndUpdateAddresses, 3600000);
  } catch (error) {
    console.error('ÏÑúÎ≤Ñ ÏãúÏûë Ï§ë Ïò§Î•ò:', error);
  }
}).on('error', (error) => {
  console.error('ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®:', error);
  process.exit(1);
});

// Ï†ïÏÉÅÏ†ÅÏù∏ Ï¢ÖÎ£å Ï≤òÎ¶¨
process.on('SIGTERM', async () => {
  console.log('Received SIGTERM signal. Shutting down gracefully...');
  
  // DiscordÏóê ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ°
  if (DISCORD_LOGGING_ENABLED && discordBot) {
    try {
      // Î¥á Ï§ÄÎπÑ ÏÉÅÌÉú ÌôïÏù∏
      if (!discordBot.isReady()) {
        console.log('Discord Î¥áÏù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. 5Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ...');
        await new Promise(resolve => setTimeout(resolve, 5000)); // 5Ï¥à ÎåÄÍ∏∞
      }
      
      if (discordBot.isReady()) {
        // Í∏∞Î≥∏ Ï±ÑÎÑêÏóê ÏïåÎ¶º Ï†ÑÏÜ°
        if (DISCORD_CHANNEL_ID) {
          try {
            const channel = await discordBot.channels.fetch(DISCORD_CHANNEL_ID);
            if (channel) {
              const shutdownEmbed = new EmbedBuilder()
                .setTitle('‚ö†Ô∏è ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏïåÎ¶º')
                .setColor(15548997) // Îπ®Í∞ÑÏÉâ
                .setDescription('@everyone\nÏÑúÎ≤ÑÍ∞Ä Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§. ÏÑúÎπÑÏä§ Ïù¥Ïö©Ïù¥ Î∂àÍ∞ÄÎä•Ìï† Ïàò ÏûàÏäµÎãàÎã§.')
                .setTimestamp()
                .setFooter({ text: 'VIP+ ÏÑúÎ≤Ñ ÏïåÎ¶º' });
                
              console.log('Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ° ÏãúÎèÑ Ï§ë...');
              const sentMessage = await channel.send({ content: '@everyone', embeds: [shutdownEmbed] });
              console.log(`ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏïåÎ¶º Î©îÏãúÏßÄÍ∞Ä DiscordÎ°ú Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§. Î©îÏãúÏßÄ ID: ${sentMessage.id}`);
            }
          } catch (error) {
            console.error('Discord Ï±ÑÎÑê Ï†ëÍ∑º ÎòêÎäî Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
          }
        }
      } else {
        console.log('Discord Î¥áÏù¥ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïÑ Ï¢ÖÎ£å ÏïåÎ¶ºÏùÑ Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('Discord Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', error);
    }
    
    // Discord Î¥á Ïó∞Í≤∞ Ï¢ÖÎ£åÎ•º Í∏∞Îã§Î¶º (Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê Ï∂©Î∂ÑÌïú ÏãúÍ∞Ñ)
    console.log('Discord Î©îÏãúÏßÄ Ï†ÑÏÜ° ÎåÄÍ∏∞ Ï§ë... (3Ï¥à)');
    await new Promise(resolve => setTimeout(resolve, 3000));
    console.log('ÎåÄÍ∏∞ ÏôÑÎ£å, ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏßÑÌñâ');
  }
  
  server.close(() => {
    console.log('Server closed');
    // ÏùºÏ†ï ÏãúÍ∞Ñ ÌõÑ Í∞ïÏ†ú Ï¢ÖÎ£å (Î©îÏãúÏßÄÍ∞Ä Ï†ÑÏÜ°ÎêòÏßÄ ÏïäÎçîÎùºÎèÑ)
    setTimeout(() => {
      console.log('Í∞ïÏ†ú Ï¢ÖÎ£å');
      process.exit(0);
    }, 1000);
  });
});

// SIGINT Ï≤òÎ¶¨ (Ctrl+C)
process.on('SIGINT', async () => {
  console.log('Received SIGINT signal (Ctrl+C). Shutting down gracefully...');
  
  // DiscordÏóê ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ°
  if (DISCORD_LOGGING_ENABLED && discordBot) {
    try {
      // Î¥á Ï§ÄÎπÑ ÏÉÅÌÉú ÌôïÏù∏
      if (!discordBot.isReady()) {
        console.log('Discord Î¥áÏù¥ ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. 5Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ...');
        await new Promise(resolve => setTimeout(resolve, 5000)); // 5Ï¥à ÎåÄÍ∏∞
      }
      
      if (discordBot.isReady()) {
        // Í∏∞Î≥∏ Ï±ÑÎÑêÏóê ÏïåÎ¶º Ï†ÑÏÜ°
        if (DISCORD_CHANNEL_ID) {
          try {
            const channel = await discordBot.channels.fetch(DISCORD_CHANNEL_ID);
            if (channel) {
              const shutdownEmbed = new EmbedBuilder()
                .setTitle('‚ö†Ô∏è ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏïåÎ¶º')
                .setColor(15548997) // Îπ®Í∞ÑÏÉâ
                .setDescription('@everyone\nÏÑúÎ≤ÑÍ∞Ä Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§. ÏÑúÎπÑÏä§ Ïù¥Ïö©Ïù¥ Î∂àÍ∞ÄÎä•Ìï† Ïàò ÏûàÏäµÎãàÎã§.')
                .setTimestamp()
                .setFooter({ text: 'VIP+ ÏÑúÎ≤Ñ ÏïåÎ¶º' });
                
              console.log('Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ° ÏãúÎèÑ Ï§ë...');
              const sentMessage = await channel.send({ content: '@everyone', embeds: [shutdownEmbed] });
              console.log(`ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏïåÎ¶º Î©îÏãúÏßÄÍ∞Ä DiscordÎ°ú Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§. Î©îÏãúÏßÄ ID: ${sentMessage.id}`);
            }
          } catch (error) {
            console.error('Discord Ï±ÑÎÑê Ï†ëÍ∑º ÎòêÎäî Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
          }
        }
      } else {
        console.log('Discord Î¥áÏù¥ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïÑ Ï¢ÖÎ£å ÏïåÎ¶ºÏùÑ Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('Discord Ï¢ÖÎ£å ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', error);
    }
    
    // Discord Î¥á Ïó∞Í≤∞ Ï¢ÖÎ£åÎ•º Í∏∞Îã§Î¶º (Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê Ï∂©Î∂ÑÌïú ÏãúÍ∞Ñ)
    console.log('Discord Î©îÏãúÏßÄ Ï†ÑÏÜ° ÎåÄÍ∏∞ Ï§ë... (3Ï¥à)');
    await new Promise(resolve => setTimeout(resolve, 3000));
    console.log('ÎåÄÍ∏∞ ÏôÑÎ£å, ÏÑúÎ≤Ñ Ï¢ÖÎ£å ÏßÑÌñâ');
  }
  
  server.close(() => {
    console.log('Server closed');
    // ÏùºÏ†ï ÏãúÍ∞Ñ ÌõÑ Í∞ïÏ†ú Ï¢ÖÎ£å (Î©îÏãúÏßÄÍ∞Ä Ï†ÑÏÜ°ÎêòÏßÄ ÏïäÎçîÎùºÎèÑ)
    setTimeout(() => {
      console.log('Í∞ïÏ†ú Ï¢ÖÎ£å');
      process.exit(0);
    }, 1000);
  });
}); 